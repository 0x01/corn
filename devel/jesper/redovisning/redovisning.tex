%&LaTeX
\documentclass[a4paper]{article}
\usepackage[active]{srcltx} % search in dvi
\usepackage[swedish]{babel}
% \usepackage[T1]{fontenc} % ger dåliga pdf-er!
\usepackage[latin1]{inputenc}

% \usepackage{icomma} % ``a,b'' typeset without space, but ``a, b'' with

% \usepackage{graphicx}
% \newcommand{\thee}{\rotatebox[origin=c]{180}{$\iota$}}

% \usepackage{amsmath}
% \usepackage{amsthm}
% \usepackage{amssymb}
% \usepackage{latexsym}
% \usepackage{hyperref}
% \usepackage[PS]{diagrams}
\usepackage{jespermacros}

\author{Jesper Carlstr\"om}

%\author{Jesper Carlstr\"om\thanks{\url{http://www.math.su.se/$\sim$jesper/}}}

\title{Delmängder i Coq\\Rapport till Erik Palmgren}

% \parindent0pt%
% \parskip2ex%

\begin{document}
\nonfrenchspacing
\maketitle


\noindent
Detta är en rapport om filerna {\sf subsets.v} och {\sf
  subsetspacked.v}, vars innehåll kan sammanfattas så här:
\begin{itemize}
\item I {\sf subsets.v} återfinns idéer från den formalisering jag
  skrev om i TYPES-proceeding för några år sen
  \cite{carlstromsubsets}. Dock har vissa saker gjorts annorlunda och
  jag koncentrerar denna text på kommentarer kring detta.
\item I {\sf subsetspacked.v} återfinns ''quotients'' packade i
  records och en massa records även för annat bruk. Idén är delvis
  absurd eftersom själva skälet till att göra delmängder såsom i {\sf
    subsets.v} är tron att packande och upp\-packande skall undvikas.
  Jag gjorde filen för att undersöka hur {\sf subsets.v} kan användas
  i en mer packnings-orienterad miljö. Några intressanta saker la jag
  märke till. De redovisas senare i denna rapport.
\end{itemize}

\tableofcontents

\pagebreak
\section{Filen {\sf subsets.v}}
\label{sec:filen-subsets.v}

Vi ska börja med att understryka att vi använder implicita argument
mycket flitigt, det blev närmast en förutsättning för att få detta
projekt användbart. 
\begin{verbatim}
Set Implicit Arguments.
Unset Strict Implicit.
\end{verbatim}
Det innebär att Coq självt räknar ut typningen i många fall, så att
man kan skriva mer polymorft. Raden ''Unset Strict Implicit'' gör att
Coq gissar ännu bättre, närmare bestämt med hjälp av syntaktisk
information som inte är invariant under definitionsmässig
likhet.

\subsection{Fördelen med delmängder som påståendefunktioner}
\label{sec:delm-som-past}


Uppfattningen av delmängder som påståendefunktioner
\cite{toolboxsubsets,carlstromsubsets} bygger på iakttagelsen att man
definierar en delmängd genom att säga
\begin{equation}
  \label{eq:1}
  x\insubset U \defeq P(x)
\end{equation}
för någon påståendefunktion $P$, varför man lika gärna kan uppfatta
''$x\insubset U$'' bara som ett annat skrivsätt för $P(x)$. Med andra
ord: det finns inget skäl att skilja delmängden $U$ från
påståendefunktionen $P$.

Denna lösning leder dock till att man måste skilja på mängder och
delmängder. Vill man undvika den skillnaden betraktar man delmängder
som $\Sigma$-mängder. Nackdelen är att $\Sigma$-typerna är
mer komplicerade än påståendefunktioner och kräver mer
byråkrati. Motsvarigheten till (\ref{eq:1}) blir att sätta
$U\defeq\Sigma(A,P)$ och konstatera att
\begin{equation}
  \label{eq:2}
  x\in U \iff \pi_r(x)\in P(\pi_\ell(x))
\end{equation}
men de båda leden är nu omdömen istället för påståenden och $\iff$ är
inte definitionsmässig likhet. Snarare skall (\ref{eq:2}) uppfattas som
att vi har vissa introduktions- och eliminationsregler för $\Sigma$.

Särskilt krånglig blir $\Sigma$-lösningen när man betraktar många
delmängder av en given konstant mängd. Detta förekommer särskilt i
formell topologi där en öppen mängd är en delmängd av en fix basmängd,
och i algebra där ideal utgör delmängder. I uttrycket $\Sigma(A,U)$ är
det endast $U$ som varieras, varför det är enklare att endast betrakta
$U$ själv.


\subsection{Nackdelen med delmängder som påståendefunktioner}
\label{sec:nackd-med-delm}

I ett stort formaliseringsprojekt som det i Nijmegen, där man vill
framställa ett bibliotek för matematik i typteori, är det inte alltid
självklart att den logiskt sett mest naturliga lösningen är den
bästa. Man har bl.a.\ att ta ställning till
\begin{itemize}
\item kommunicerbarhet -- lösningen skall vara lätt att förstå för
  andra användare, en alltför ny lösning är dålig även om den är en
  förbättring
\item läsbarhet -- vid arbete vid dator bryr man sig om att Coq klarar
  av att presentera materialet på ett överskådligt sätt, om då Coq
  inte är lika bra på att hantera påståendefunktioner som mängder så
  är det ett argument för $\Sigma$-lösningen
\item modulerbarhet -- ett sätt att betrakta rationella tal är såsom
  en delmängd av mängden av formella bråk. Men huruvida $\Q$ ska vara
  en mängd eller en delmängd bör inte synas på makronivå. Det är svårt
  att uppnå eftersom typskillnad alltid syns på makronivå i Coq. Genom
  att alltid hålla sig till mängder snarare än delmängder gör man
  därför biblioteket likformigt och lättare att använda.
\item teknikaliteter -- diverse larviga aspekter som har med nuvarande
  Coq-implementationen att göra och som jag redogör för nedan.
\end{itemize}


\subsection{Innehållet i {\sf subsets.v}}
\label{sec:inneh-subsets.v}

Jag definierar först binära relationer på typer.
\begin{verbatim}
Definition bin (X:Type) := (X->X->CProp).
\end{verbatim}
och därefter sådant som vad det är att vara reflexiv, symmetrisk och
transitiv. Begreppet ekvivalensrelation undviker jag däremot, eftersom
jag ville prova att arbeta utan konjugerade begrepp.

Vi kommer sedan till avsnittet om delmängder. Coq har en mekanism som
kallas ''sections''. Inom en sådan kan man göra antaganden om
variabler, som sedan abstraheras när man går ur sektionen. 


\subsubsection{Section subsets.}
\label{sec:section-subsets}

Vi skriver alltså
\begin{verbatim}
Section subsets.

Variable (carrier:Type).

Definition subset (X:Type) : Type := X->CProp.
\end{verbatim}
och får på så sätt en familj ''subset X'' av delmängder av $X$. Vi
kan säga vad det innebär att vara ett element i en delmängd och införa
infixnotation för detta:
\begin{verbatim}
Definition insubset (x:carrier) (U:subset carrier) := U x.
Infix "in" := insubset (at level 60).
\end{verbatim}
så att vi kan skriva ''x in U'' för att säga att $x$ är en delmängd av
$U$. 
Därefter inför vi diverse operationer på delmängder:
\begin{verbatim}
Definition intersection (U V:subset carrier) x := x in U and x in V.
Definition union (U V:subset carrier) x := x in U or x in V.
Definition complement (U:subset carrier) x := Not (x in U).

Definition intersection_family (I:Type) (U:I->(subset carrier)) x :=
  forall i:I, x in U i.

Definition union_family (I:Type) (U:I->(subset carrier)) x :=
  {i:I | x in U i}.
\end{verbatim}
Notationen \verb/{i:I | x in U i}/ är lite olycklig i
sammanhanget: den är standardnotation för existenskvantor i CoRN.

Vidare definieras relationer mellan delmängder, såsom inklusion och
extensionell likhet:
\begin{verbatim}
Definition includedin (U V:subset carrier):= forall x:carrier, 
    x in U -> x in V.

Infix "<=" := includedin (at level 70).

Definition extequal (U V:subset carrier) := (U <= V) and (V <= U).

Infix "=_ext" := extequal (at level 70).
\end{verbatim}
och det visas att likheten är en ekvivalensrelation:
\begin{verbatim}
Lemma extequal_refl: refl (extequal).
Proof.
intros U.
split; intro p; trivial.
Qed.

Lemma extequal_sym: sym extequal.
Proof.
intros U V [p q].
split; auto.
Qed.

Lemma extequal_trans: trans extequal.
Proof.
intros U V W [p q] [r s].
split; intros a t; auto.
Qed.
\end{verbatim}

Slutligen några resultat om binärt snitt varande lika med snitt av
binär familj. Hoppar över detta.

Efter avsnittet måste vi tala om vilken notation som skall vara
tillgänglig även utanför det:
\begin{verbatim}
Infix "in" := insubset (at level 60).
Infix "/\" := intersection.
Infix "\/" := union.
Notation "~ U" := (complement U).
Notation "'for' x 'in' U , P" :=
    (forall (x':_) (x:x' in U), P)
    (at level 200, x ident).
Notation "'exists' x 'in' U , P" :=
    {x':_ |{ x:(x' in U) | P}}
    (at level 200, x ident).
Infix "<=" := includedin.
Infix "=_ext" := extequal (at level 70).
\end{verbatim}


\subsubsection{Section subsetalgebra}
\label{sec:sect-subsetalg}

I detta avsnitt antas att vi har att göra med fyra delmängder och det
skall visas att operationer på dem är extensionella:
\begin{verbatim}
Section subsetalgebra.

Variable carrier:Type.
Variables U V U' V':subset carrier.
\end{verbatim}

Här är de små resultaten, som demonstrerar ganska bra hur man arbetar
i Coq.
\begin{verbatim}
Lemma intersection_ext:
   (U =_ext U') -> (V =_ext V') -> ((U /\ V) =_ext (U' /\ V')).
Proof.
intros [p q] [r s].
split; intros a [u v]; split; auto.
Qed.

Lemma union_ext:
   (U =_ext U') -> (V =_ext V') -> ((U \/ V) =_ext (U' \/ V')).
Proof.
intros [p q] [r s].
split; (intros a [u | v]; [left | right]; auto).
Qed.

Lemma complement_ext: (U =_ext V) -> ((~ U) =_ext (~ V)).
Proof.
intros [p q].
split; intros a r s; auto.
Qed.

Lemma deMorgan: (~ (U \/ V)) =_ext (~ U /\ ~V).
Proof.
split.
intros a p.
split; intro q; apply p; [left|right]; assumption.
intros a [p q] [r|s]; auto.
Qed.
\end{verbatim}


\subsubsection{Section quotients.}
\label{sec:section-quotients}

Avsikten med denna del är att införa ekvivalensrelationer på
delmängder. Vi antar därför att vi har att göra med en viss delmängd,
här kallad ''domain'', samt definierar vad vi menar med en binär
relation på den. Notera bruket av den nyligen definierade notationen
''for x in domain, ...''.

\begin{verbatim}
Variables carrier:Type.
Variable domain:subset carrier.

Definition bin_on := (for x in domain, for y in domain, CProp).

Variable R:bin_on.

Infix "~" := R (at level 70). 
\end{verbatim}
Egentligen tar $R$ fyra argument $x p y q$ där $p$ och $q$ bevisar att
$x$ och $y$ tillhör domänen. P.g.a.\ implicita argument behöver man
inte skriva ut $x$ och $y$, eftersom Coq kan härleda dem från $p$ och
$q$. Notera att detta använder sig av ostrikt läge, eftersom $x$
härleds från att vi har ''p:x in domain'', men om ''x in domain'' är
definitionsmässigt lika med ''True'' så kan vi konvertera omdömet
''p:x in domain'' till ''p:True'', vilket inte innehåller information
om $x$. 

Eftersom Coq kan extrahera info om $x$ och $y$ ur $p$ och $q$, har jag
tagit till följande lilla trick: 
\begin{quote}
  Jag använder notationen \verb/x/ för $p$ och \verb/y/ för $q$, medan $x$
  och $y$ noteras \verb/x'/ respektive \verb/y'/.
\end{quote}
Det gör att man får den trevliga illusionen att man arbetar endast med
de underliggande objekten, medan Coq håller ordning på de tillhörande
bevisobjekten. I själva verket är det alltså tvärt om, men detta
visade sig fungera mycket bra och ger överskådlig och lättläst kod.

Vi kan på detta sätt definiera reflexivitet, symmetri och
transitivitet för $R$:
\begin{verbatim}
Definition refl_part := for x in domain, x~x.

Definition sym_part := for x in domain, for y in domain, x~y -> y~x.

Definition trans_part := 
   for x in domain,
   for y in domain,
   for z in domain,   x~y -> y~z -> x~z.
\end{verbatim}

Vi definierar också en egenskap som är viktig att kräva för att
ekvivalensrelationer på delmängder inte skall vara för fina, nämligen
en form av bevisirrelevans. Argumenten för denna återfinns i
\cite{carlstromsubsets}.
\begin{verbatim}
Definition proofirr :=
   for x in domain,
   for y in domain,
   forall z:(underlying x) in domain,
   forall w:(underlying y) in domain,
   z~w -> x~y.
\end{verbatim}
där \verb/underlying/ definierats så här:
\begin{verbatim}
Definition underlying (x':carrier) (_:x' in domain) := x'.
\end{verbatim}

Den finaste av alla möjliga reflexiva och bevisirrelevanta relationer
kallar vi för \verb/same/. Den betyder att de underliggande objekten
är id-lika.
\begin{verbatim}
Definition same:bin_on := fun
   (x':_) (x:x' in domain)
   (y':_) (y:y' in domain) =>
    x'=y'.

Lemma strongrefl: proofirr ->
                  refl_part -> 
                  forall a:carrier,
                  forall (x y:a in domain),
                  x~y.
Proof.
intros Hpirr Hrefl a x y.
apply Hpirr with x x.
apply Hrefl.
Qed.

Lemma same_finest: proofirr ->
                   refl_part ->
                   for x in domain,
                   for y in domain,
                   same x y -> x ~ y.
Proof.
intros Hpirr Hrefl x' x y' y; compute.
destruct 1; apply strongrefl; assumption.
Qed.
\end{verbatim}

Varje total ekvivalensrelation kan skäras ner till en bevisirrelevant
ekvivalensrelation på en delmängd och omvänt kan varje sådan utvidgas
till en total relation genom reflexivt hölje.

\begin{verbatim}
Definition reflexive_closure : bin carrier := 
    fun x' y':carrier => 
   (x'=y') or {x:(x' in domain) | {y:(y' in domain) | x~y}}.

(** reflexive relations on subsets extend to reflexive relations *)

Lemma reflexive_closure_refl: refl reflexive_closure.
Proof.
intros x'.
left; auto.
Qed.

(** symmetric relations on subsets extend to symmetric relations *)

Lemma reflexive_closure_of_sym_sym: sym_part -> sym reflexive_closure.
Proof.
intros s x' y' [eq|H].
 left; symmetry; assumption.
existse H x H.
existse H y H.
right; exists y; exists x; auto.
Qed.


(** Interestingly, we don't have the analogous lemma for transitivity,
since it might happen that we have 

   - [R x' x y' y]
   - [R y' u z' z]

and so the reflexive closure will identify x' with y' and y' with z',
but not necessarily x' with z' (because y need not be the same as
u). We need also proofirr to prove transitivity. *)

Lemma reflexive_closure_of_pirr_trans_trans: 
   proofirr -> trans_part -> trans reflexive_closure.
Proof.
intros Hpirr Htr x' y' z' [id| p].
  destruct id.
  intros [id| p].
    destruct id.
    left; reflexivity.
  existse p x H.
  existse H z e.
  right; exists x; exists z; assumption.
existse p x H.
existse H y e.
intros [id| p].
  destruct id.
  right; exists x; exists y; assumption.
existse p y2 H.
existse H z e2.
right; exists x; exists z.
apply Htr with y' y; auto.
apply Hpirr with y2 z; auto.
Qed.
\end{verbatim}



\subsubsection{Section partialfunctions.}
\label{sec:sect-part}

Vi inför en vacker notation för partiella funktioner...
\begin{verbatim}
Notation "U ~> B" := (for x in U, B).
\end{verbatim}
Vidare gör vi några antaganden om att vi har att göra med två
delmängder med relationer på och en partiell funktion emellan, samt
definierar vad det innebär att den går \emph{in} i codomänen.
\begin{verbatim}
Variables carrier cocarrier:Type.
Variable domain:subset carrier.
Variable codomain:subset cocarrier.
Variable R:bin_on domain.
Variable R_co:bin_on codomain.
Variable f:domain ~> cocarrier.

Infix "~" := R (at level 70).
Infix "~~" := R_co (at level 70).

Definition into := for x in domain, f x in codomain.
\end{verbatim}

Notera att en partiell funktion i sig inte bär ett bevis att den går
in i codomänen. Detta är istället något vi kan säga om den. Det
innebär att vi kan säga saker som ''Den partiella funktionen $f$ går
in i delmängden $U$, men inte in i delmängden $V$''.

Definitionerna av extensionalitet ser ut så är:
\begin{verbatim}
Definition extensional :=
   for x in domain, 
   for x' in domain, 
   forall y:f x in codomain,
   forall y':f x' in codomain,
   x~x' -> y~~y'.
\end{verbatim}
Dualt har vi begreppet injektivitet:
\begin{verbatim}
Definition injective :=
   for x in domain, 
   for x' in domain,
   forall y:f x in codomain,
   forall y':f x' in codomain,
   y ~~ y' -> x ~ x'.
\end{verbatim}

För att definiera surjektivitet följer vi Bishop och säger att en
funktion är surjektiv om den har en (inte nödvändigtvis extensionell)
högerinvers (detta är ett exempel när det är bra att inte utgå från
att alla partiella funktioner är extensionella). Att $g$ är
högerinvers till $f$ uttrycker vi med \verb/isinv R_co f g/.
\begin{verbatim}
Definition isinv : CProp :=
                 for y in codomain,
                 forall x:(g y in domain),
                 forall y':(f x in codomain), y' ~~ y.
\end{verbatim}
Begreppet beror alltså på \verb/R_co/.


\subsubsection{Section bijections.}
\label{sec:section-bijections}

Detta avsnitt innehåller några resultat om att högerinversen till en
surjektiv funktion $f$ är extensionell om $f$ är injektiv etc. Jag
utelämnar detaljerna, de finns i filen.


\subsubsection{Section compositions.}
\label{sec:sect-comp}

Nu ser vi en nackdel med en platt attityd: vi måste göra många
antaganden i början av denna avdelning:
\begin{verbatim}
Variables A B C:Type.
Variable X:subset A.
Variable Y:subset B.
Variable Z:subset C.

Variable RX:bin_on X.
Variable RY:bin_on Y.
Variable RZ:bin_on Z.

Hypothesis Xpirr:proofirr RX.
Hypothesis Ypirr:proofirr RY.
Hypothesis Zpirr:proofirr RZ.

Hypothesis Xrefl:refl_part RX.
Hypothesis Yrefl:refl_part RY.
Hypothesis Zrefl:refl_part RZ.

Hypothesis Xsym:sym_part RX.
Hypothesis Ysym:sym_part RY.
Hypothesis Zsym:sym_part RZ.

Hypothesis Xtr:trans_part RX.
Hypothesis Ytr:trans_part RY.
Hypothesis Ztr:trans_part RZ.

Variable f:X ~> B.
Variable g:Y ~> C.

Hypothesis f_i:into Y f.
\end{verbatim}

Fördelen är att vi kan använda antagandena fritt inom sektionen men
när vi stänger den kommer varje lemma endast att bero på de antaganden som
faktiskt användes i beviset av det. På det sättet får vi generalitet gratis.

Vi definierar också vad sammansättning är och inför trevliga sätt att
skriva ekvivalensrelationerna på:
\begin{verbatim}
Definition composition (a:A) (x:a in X) := g (f_i x).

Infix "~X" := RX (at level 70).
Infix "~Y" := RY (at level 70).
Infix "~Z" := RZ (at level 70).
\end{verbatim}

Vi visar sedan sådant som att sammansättning är extensionell om
delarna är det, att den är injektiv om delarna är det, och att den är
surjektiv om delarna är det.


\subsubsection{Section finiteness.}
\label{sec:section-finiteness}

Vi hanterar här ändliga delmängder. Ändlighet skall vara ett predikat
som vi kan tillämpa på delmängder med ekvivalensrelationer. Vi
definierar därför en standardfamilj av ändliga delmängder såsom
initiella segment till de naturliga talen och säger att en delmängd är
ändlig omm den är i bijektiv korrespondens med något sådant initiellt
segment.
\begin{verbatim}
Definition fin n : subset nat := fun k => {l:nat | k + S l = n}.
\end{verbatim}

Diverse resultat om diskrethet av ändliga delmängder etc följer.

Hofmanns sats (med Hedbergs bevis) om att likhet mellan naturliga tal
har högst ett bevis används för att visa att bevis av att k tillhör
fin n är unika. Det används i sin tur för att visa ändligt
extensionellt urval: om vi har en surjektion till en ändlig delmängd
så finns en extensionell högerinvers. Det är filens sista resultat.


\section{Filen {\sf subsetspacked.v}}
\label{sec:filen-packed}

Frågan uppkom huruvida det är bra eller dåligt med en fil som är så
platt som min {\sf subsets.v} är. Jag gjorde därför en annan fil som
använder sig av {\sf subsets.v} men är mer packad. Första steget är
naturligtvis att definiera begreppet ekvivalensrelation
\begin{verbatim}
Record eq_rel (A:Type)(R:bin A):Type :=
{  eq_rel_refl:refl R;
   eq_rel_sym:sym R ;
   eq_rel_trans:trans R }.
\end{verbatim}
och bevisa sådant som att extensionell likhet är en
ekvivalensrelation. Precis som man skulle önska är det bara att
tillämpa lemman från föregående fil:
\begin{verbatim}
Lemma extequal_eq: forall (A:Type), eq_rel (extequal (carrier:=A)).
Proof.
split.
    apply extequal_refl.
  apply extequal_sym.
apply extequal_trans.
Qed.
\end{verbatim}

Analogt definierar vi ekvivalensrelationer på delmängder:
\begin{verbatim}
Record eq_part (A:Type)(U:subset A)(R:bin_on U): CProp :=
{
   eq_part_pirr:   proofirr R ;
   eq_part_refl:   refl_part R;
   eq_part_sym:    sym_part R;
   eq_part_tr:     trans_part R
}.
\end{verbatim}
Denna definition kommer senare att leda till problem, eftersom flera
av mina lemman kräver att en relation är reflexiv, men vi har inte
det, utan bara att den är en ekvivalensrelation. För Coq är det inte
självklart att ekvivalensrelationer är reflexiva, så vi måste lära Coq
det:
\begin{verbatim}
Hint Immediate eq_part_pirr : subsets.
Hint Immediate eq_part_refl : subsets.
Hint Immediate eq_part_sym : subsets.
Hint Immediate eq_part_tr : subsets.
\end{verbatim}
Avslutningen '':subsets'' betyder att tipsen stoppas i en tipsdatabas
som heter subsets. Vi kan sedan använda dessa tips med en taktik
''sauto'', som definierats i Ltac på följande vis:
\begin{verbatim}
Ltac sauto := auto with subsets.
\end{verbatim}

Vi bevisar nu att reflexiva höljet av an ekvivalensrelation på en
delmängd är en total ekvivalensrelation. Återigen kan vi använda
färdiga lemman:
\begin{verbatim}
Lemma reflexive_closure_of_eq_eq: forall (A:Type)(U:subset A)(R:bin_on U),
   eq_part R -> eq_rel (reflexive_closure R).
Proof.
intros A U R [Href Hsym Htr Hext].
split.
    apply reflexive_closure_refl.
  apply reflexive_closure_of_sym_sym; assumption.
apply reflexive_closure_of_pirr_trans_trans; assumption.
Qed.

Därefter följer ett bevis av att ''same'' är en ekvivalensrelation,
vilket utelämnas.

Definitionen av surjektivitet följer Bishop:
\begin{verbatim}
Record surjective (A B:Type) (U:subset A) (V:subset B) (RV:bin_on V) (f:U~>B)
: CProp := {
   fun_i: into V f ;
   inv : V ~> A ;
   inv_i: into U inv ;
   isinv_pf : isinv RV f inv }.
\end{verbatim}

Slutligen plockar vi ihop carrier, delmängd och ekvivalensrelation i
en record. Personligen anser jag idén vara absurd, eftersom man då får
något som är i det närmaste identiskt med setoider (så varför göra
något nytt?). Det är dock instruktivt att se hur det fungerar.
\begin{verbatim}
Record quotient : Type :=
{
   q_carrier: Type ;
   q_subset:  subset q_carrier ;
   q_rel:     bin_on q_subset ;
   q_eq:      eq_part q_rel
}.
\end{verbatim}

Resten av filen är i stort sett en upprepning av subsets.v, så jag
skriver inte mer om den här utan rekommenderar skumning av den för att
se hur saker ser ut.



\section{Sammanfattning}
\label{sec:sammanfattning}

Filen {\sf subsets.v} följer nära traditionen av delmängder som
påståendefunktioner. Fördelarna är de man skulle vänta sig. Oväntade
nackdelar är att man ofta får många delmål av Coq att bevisa,
visserligen är de triviala men de kan vara väldigt många. Exempelvis:
istället för förutsättningen att en relation är en ekvivalensrelation
får man fyra förutsättningar att visa: reflexivitet, symmetri,
transitivitet, bevisirrelevans. Det har dock alltid gått att bevisa
sådana förutsättningar med taktiken sauto, som är auto utvidgad med
tips speciellt anpassade för delmängder.



\bibliographystyle{jesper}
\bibliography{all}

\

\

Se också filerna {\sf subsets.v} och {\sf subsetspacked.v}.

\end{document}
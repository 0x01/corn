(* requires excluded middle )
(*! requires excluded middle and choice)

There is a notion of set; there is a notion of member. If x is a set,
and a is a member then a in x is an assertion. If a, b in x, then a=b
is an assertion (at least an equivalence relation).

If x is a set, then there is a set (Pred x):
if a in x and P in (Pred x), then (P a) is an assertion.

If x in set and P in (Pred x), then (x|P) in set;
a in (x|P) iff a in x and (P a). % I have this all implemented.
----------------------------------------------------------------- 
There is a notion (Pred2 x) a set of binary relations on x:
if a, b in x, and R in (Pred2 x), then (R a b) may hold or not.
If P in (Pred2 x) and a in x, then
\b.(P a b) in (Pred x)such that
((\b.(R a b)) c) iff (R a c).
----------------------------------------------------------------- 
If x,y are sets, then so is (x->y);
if f in (x->y) and a in x, then (f a) in y.

= on the elements of a set is a congruence relation: 
a=b -> (f a)=(f b).

If f in (x->y) and g in (y->z), then gof in (x->z) and
gof a = g(f a).
----------------------------------------------------------------- 
There is a notion of product: if x,y are sets, so is x \x y.  If a in
x, b in y, then (a,b) in x \x y. There are projections pi: x1 \x x2 ->
xi such that pi (a1,a2)=ai. Every element of x \x y is a pair of
elements of x and y.

(a1,a2)=(b1,b2) iff a1=b1 and a2=b2.

A relation between set x, y is a Pred on x \x y.
----------------------------------------------------------------- 
A predicate P on x is decidable iff 
forall a in x,(P x)\/~(P x);
similarly for relations.
----------------------------------------------------------------- 
If x is a set and R is an equivalence relation on x, then 
x/R is a set. There is a surjective map
[ ]:x -> x/R such that for a, b in x
[a]=[b] iff (R a b).
----------------------------------------------------------------- 
f in (x->y) is an injection, surjection, bijection.

x =<1 y iff there is an injection in x->y;
x=1 y iff there is a bijection in x->y.

nat is a Set; 0 in nat, S:nat -> nat.
1=(S 0), 2=(S 1).
There is < in (Pred2 nat); if k in nat, then
(nat|\b. b<k)=nat_k.

x is empty iff x=1 nat_0.
x is finite iff for some k in nat (x=1 nat_k).
x is inf1 iff x not finite.
x is inf2 iff (nat =<1 x).

nat is inf1, inf2.

If x is finite and P (predicate on x) is decidable, then 
(x|P) is finite.
-----------------------------------------------------------------
x <1 (x->x_2), Cantor's theorem.
x <1 (Pw x).
* x =<1 y and y =<1 x implies x =1 y. (Schroeder-Bernstein).
* x <1 y -> f:y->x -> exists b1,b2:y, (f b1)=(f b2)
(pigeonhole principle).
*! x =<1 y or y =<1 x.
----------------------------------------------------------------- 
If x is a set, and P,Q range over predicates over x one may form
P intersection, union Q;
C P (complement);
P sub Q is an assertion.
P=Q iff ((P a) iff (Q a)).
C(P U Q)=C(P)^C(Q).
* C(P^Q)=C(P) U C(Q). 
* C(C P)=P.
Functions on predicates over x preserve =:
for f in (Pred x)->y and P1 P2 in (Pred x) one has
P1=P2 ->(f P1)=(f P2).
----------------------------------------------------------------- 
A sequence in x is an element of (nat -> x).
If s1 s2 are sequences in x, then s2 is a subsequence of s1 iff
s2=s1 o f for some f in (nat->nat).

A permutation on a set x is an element of (x->x) that is a bijection.
S_k consistes of the permutations on N_k.
----------------------------------------------------------------- 

Approaches.

1 Setoids: 	(A,~) 	~ eq. rel.
2 Subs:		(A,P) 	P predicate.
3 SetoidSubs: 	((A,~),P)
4 SetoidSubs2:  (A,~,P)
5 Pers: 	(A,R) 	R binary, transitive, symmetric

With universe 
Inductive unv:Type:=
          InU: forall A:Set, forall a:A, unv.

6 USubs:        (unv,P)		P, predicate on unv.
7 UPer: 	(unv,R)		Pers on unv.



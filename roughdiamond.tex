\documentclass{llncs}
\usepackage{url}
\usepackage{bbm}
\usepackage[utf8x]{inputenc}
\newcommand{\N}{\ensuremath{\mathbbm{N}}}
\newcommand{\Z}{\ensuremath{\mathbbm{Z}}}
\newcommand{\Q}{\ensuremath{\mathbbm{Q}}}
%include coq2tex.tex
\arrayhs %i.e. no page breaks in code blocks
\divide\abovedisplayskip 4
\divide\belowdisplayskip 4
\begin{document}
\title{Developing the algebraic hierarchy with type classes in Coq}
\author{Bas Spitters \and Eelis van der Weegen}
\institute{Radboud University Nijmegen}
\maketitle
\begin{abstract}
We present a new formalization of the algebraic hierarchy in Coq, exploiting its newly obtained type class implementation to make practical a solution formerly thought infeasible. Our approach addresses both traditional challenges as well as new ones resulting from our ambition to build upon this development a library of constructive analysis in which abstraction penalties affecting efficient computation are reduced to a bare minimum.
\end{abstract}

\section{Introduction}
The development of libraries for formalized mathematics presents many software engineering challenges ~\cite{C-corn,DBLP:conf/types/HaftmannW08} arising from the fact that it is far from obvious how the clean, idealized concepts from everyday mathematics should be represented using the facilitities provided by concrete theorem provers and their formalisms, in a way that is both mathematically faithful and convenient to work with.

For the algebraic hierarchy---a critical component in any library of formalized mathematics---these challenges include structure inference, handling of multiple inheritance, idiomatic use of notations, and convenient algebraic manipulation.

Several solutions have been proposed for the Coq theorem prover: dependent records~\cite{DBLP:journals/jsc/GeuversPWZ02} (a.k.a. telescopes), packed classes~\cite{Packed}, and occasionally modules. We present a new approach based entirely on Coq's recently obtained type classes, and show how their features together with a key design pattern let us effectively address the challenges mentioned above.

Since we intend to use this development as a basis for constructive analysis with practical certified exact real arithmetic, an additional objective and motivation in our design is to facilitate \emph{efficient} computation. In particular, we want to be able to effortlessly swap implementations of number representations. Doing this requires that we have clean abstract interfaces, and mathematics tells us what these should look like: we represent $\N$, $\Z$, and $\Q$ as \emph{interfaces} specifying an initial semiring, an initial ring, and a field of integral fractions, respectively.

To express these elegantly and without duplication, our development\footnote{The sources are available
at:~\url{http://www.eelis.net/research/math-classes/}} includes an integrated formalization of the basics of category theory and multi-sorted universal algebra, all expressed using type classes where appropriate.

% In
% Coq, type classes have advantages over modules\footnote{
% Modules are sections on steroids: namespace management, notations, hints, etc.
% The [Import] command imports all the constants from a module. Thus allowing the user to type B
% instead of A.B
% }:
% they are first class and extract~\cite{letouzey02} to Haskell\footnote{
% Would module like extraction be possible?}.

%Our contributions are:\footnote{The sources are available at:~\url{http://www.eelis.net/research/math-classes/}}%
%\begin{itemize}\itemsep=0pt
% \item The implementation of an algebraic hierarchy based on type classes, addressing the
%issues raised above; see Section~\ref{classes}.
% \item A formalization of many-sorted universal algebra in Coq, including a construction of
%free $\Sigma$-algebras; Section~\ref{univ}.
%\end{itemize}

\section{Algebraic hierarchy using type classes}\label{classes}
\vspace*{-2ex}
We represent each structure in the algebraic hierarchy as a type class. In Coq, type classes and their instances are realized as record types (``dictionaries'') and registered constants of these types. This immediately leads to the familiar question of which components of the structure are to become parameters, and which are to become record(/class) fields. By far the most important design choice in our development is the decision to turn all \emph{structural} components (i.e. carriers, relations, and operations) into parameters, keeping only \emph{properties} as fields. Type classes defined this way are essentially predicates with automatically resolved proofs.

Conventional wisdom warns that while this approach is theoretically very flexible (as we will see momentarily), one risks extreme inconvenience both in having to declare and pass around all these structural components all the time, as well as in losing notations (because we no longer project named operations out of records).

These are legitimate concerns that we avoid by exploiting the way Coq type classes and their support infrastructure work, using \emph{operational type classes}: classes with a single field representing a single relation or operation in isolation. Such classes are treated specially by Coq in being translated to mere definitions rather than records, with the field projection becoming the identity function.
\begin{code}
 Class Equiv A := equiv: relation A.
 Infix "=" := equiv (at level 70, no associativity).
\end{code}
These operational type classes serve to establish \emph{canonical names}, which not only let us bind notations, but also allow us to make their declaration and passing implicit in most contexts. For instance, using the following definition of semirings, all structural parameters (represented by operational classes declared with curly brackets) will be implicitly resolved by the type class mechanism rather than listed explicitly whenever we talk about semirings.
\begin{code}
Class SemiRing A {e: Equiv A}{plus: RingPlus A}{mult: RingMult A}
                 {zero: RingZero A}{one: RingOne A}:Prop :=
  { semiring_mult_monoid:> Monoid A (op:=mult)(unit:=one)
  ; semiring_plus_monoid:> Monoid A (op:=plus)(unit:=zero)
  ; semiring_plus_comm:> Commutative plus
  ; semiring_mult_comm:> Commutative mult
  ; semiring_distr:> Distribute mult plus
  ; mult_0_l: forall x, 0 * x == 0 }.
\end{code}
The concrete Coq infrastructure (added specifically to support type classes) that makes this work consists of implicit quantification (when declaring a semiring), and maximally inserted implicit arguments (when stating that something is a semiring, and when referring to operations and relations).

Having argued that the \emph{all-structure-as-parameters} approach \emph{can} be made practical, we enumerate some of the benefits that make it worthwhile.

First, multiple inheritance becomes trivial: |SemiRing| inherits two |Monoid| structures on the same carrier and setoid relation, using ordinary named arguments (rather than dedicated extensions \cite{DBLP:conf/types/Luo08}) to achieve ``manifest fields''.

Second, because our terms are small and independent and never refer to proofs, we are invulnerable to concerns about efficiency and ambiguity of projection paths (obviating the need for things like the proposed coercion pullbacks~\cite{Hints}).

Third, since our structural type classes are mere (proof-irrelevant) predicates, overlap between their instances is a non-issue. Together with the previous point, this gives us tremendous freedom to posit multiple structures on the same operations and relations, including ones derived implicitly via subclasses.

% Coercion pullbacks~\cite{Hints} were introduced to address problems with multiple coercions paths,
% as in the definition of a semiring: a type with two monoid structures on it. We avoid some
% of these problems by explicitly specifying the fields. We emphasize that the semiring properties are automatically derived from the ring
% properties, although the properties of a semiring are not structurally included in the ring
% properties.


\section{Universal algebra}\label{univ}
After having implemented concrete algebraic structures, we generalized some of our constructions
by implementing many-sorted universal algebra. A formalization of universal algebra
already exists in Coq~\cite{DBLP:conf/tphol/Capretta99}. We have conveniently redeveloped most of it
using type classes, moreover we have added a categorical framework. For instance, we show that the
term-algebra for a signature is initial. We defined equational theories and their categories of
their models. A quote function helps to translate a statement for an instance of
a type class to a statement in the equational logic. We have a prototype automatic quoting mechanism
using type classes similar to that using unification hints~\cite{Hints} .

We plan to include the first homomorphism theorem and perhaps the soundness theorem for equational
logic

%There is a slight problem when defining the forgetful functor from the category of
%$\Sigma$-algebras to Sets. This problem is caused by our use of the category of all
%categories\footnote{Perhaps we should have used higher categories for this.}.
%We conjecture that this problem disappears when Coq's universe polymorphism is extended to
%definitions.

\section{Interfaces using category theory}\label{interfaces}\label{modul}
The current work was stimulated by our desire~\cite{Riemann} to move between several
implementations in a flexible way. We use ad-hoc polymorphism to capture the natural
numbers without referring to their actual implementation, we have
characterized them as the initial object in the category of semirings and derived many of its
properties from this interface. Unary, binary and machine numbers are
instances of this interface, so we can directly apply these results to them.

We encourage more efficient implementations by assigning the default implementation a
low priority. For example, the distance function on the natural numbers, which is derived from its
semiring structure, is assigned priority 10.
\begin{code}
  Global Program Instance: NatDistance N | 10 := ...
\end{code}

\section{Conclusions}
Telescopes have been criticized~\cite{Packed} for the lack of multiple inheritance and
the efficiency penalty of a long chain of coercion projections. Packed classes~\cite{Packed} provide
a solution to these problems. We provide an alternative solution. We have already
discussed multiple inheritance in Section~\ref{hierarchy}. Moreover, by exposing the
carrier we avoid the chains of projections.

Packed classes use canonical structures for the algebraic hierarchy and a uniform notation. Both
canonical structures and
type classes may be seen as instances of hints in unification~\cite{Hints}. Some uses of canonical
structures can be replaced by type class instances. The user manual (2.7.15) uses canonical
structures to derive the setoid equality on the natural
numbers in the following example |(S x)==(S y)|. We have reimplemented this with
type classes with similar proof terms. Canonical structures give
\begin{code}
@equiv(Build_Setoid nat (@eq nat)(@eq_equivalence nat))(S x)(S y)
\end{code}

which includes an explicit proof that |(@eq nat)| is an equivalence,
whereas we obtain |@equiv nat (@eq nat) (S x) (S y)|.

According to |coqwc|, our development consists of 4479 lines of specifications and 722 lines of
proofs.

\paragraph{Acknowledgements.}
We would like to thank Matthieu Sozeau for discussions and quickly solving numerous small bugs and
feature requests.
\bibliographystyle{plain}
\bibliography{alg}
\end{document}

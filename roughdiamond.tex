\documentclass[a4paper,10pt]{llncs}
\usepackage{url}
\usepackage{bbm}
\usepackage[utf8x]{inputenc}
\newcommand{\N}{\ensuremath{\mathbbm{N}}}
\newcommand{\Z}{\ensuremath{\mathbbm{Z}}}
\newcommand{\Q}{\ensuremath{\mathbbm{Q}}}
%include coq2tex.tex
\arrayhs %i.e. no page breaks in code blocks
\divide\abovedisplayskip 4
\divide\belowdisplayskip 4
\begin{document}
\title{Developing the algebraic hierarchy with type classes in Coq}
\author{Bas Spitters \and Eelis van der Weegen}
\institute{Radboud University Nijmegen}
\maketitle
\begin{abstract}
We propose generic design patterns to organize algebraic structures using type classes inside the
Coq system. We support multiple inheritance, sharing of notations and theories, and automated
structure inference. A library for many-sorted universal algebra abstracts from the specific
algebraic structures and aids the organization of the library. Finally, we provide abstract
interfaces for $\N$, $\Z$, $\Q$ as the initial semiring, the initial ring and a field of
fractions.
\end{abstract}

\section{Introduction}
Developing formalized libraries for mathematics requires a detailed analysis of the architecture~\cite{C-corn,DBLP:conf/types/HaftmannW08}, similar to that of a large software project. 
The development of an algebraic hierarchy is an important aspect. Challenges include: 1. multiple
inheritance: A ring is a type with two operations. How do we inherit from the two theories of
monoids? 2. Sharing of notations. 

Several solutions have been proposed for the Coq theorem prover%~\cite{Coq,BC04}
: dependent
records~\cite{DBLP:journals/jsc/GeuversPWZ02} (a.k.a.\ telescopes), packed classes~\cite{Packed} and
occasionally modules. Although the latter option is quickly discarded%
\footnote{Modules are not first class, but currently they seem to be superior for extraction
purposes%~\cite{letouzey02}%
.}, considering
algebraic theories as `interfaces', as opposed to `modules', has been an important
guiding principle~\cite{Packed}.

In this fashion we implement\footnote{The sources are available at:~\url{http://www.eelis.net/research/math-classes/}}%
 algebraic theories as type classes, not instances, thus addressing the
challenges above; see Section~\ref{classes}. Type classes have recently entered Coq~\cite{DBLP:conf/tphol/SozeauO08}. In Coq
type classes are \emph{first class} citizens based on dependent records. The presence of dependent types makes them even more
powerful than the already succesful second class implementations in Haskell and Isabelle. Moreover,
Coq's type classes are well integrated with setoid-rewriting~\cite{Setoid-rewrite}.

% In
% Coq, type classes have advantages over modules\footnote{
% Modules are sections on steroids: namespace management, notations, hints, etc.
% The [Import] command imports all the constants from a module. Thus allowing the user to type B
% instead of A.B
% }:
% they are first class and extract~\cite{letouzey02} to Haskell\footnote{
% Would module like extraction be possible?}.

We abstract from concrete algebra and formalize many-sorted universal algebra, including a construction of
free $\Sigma$-algebras; Section~\ref{univ}. Finally, we are concerned with efficiency. So, we would like to replace data structures with more efficient ones. For instance, 
Coq provides unary, binary and machine numbers. Hence, we use ad-hoc polymorphism with type classes to
develop a unified library for them; see Section~\ref{modul}. The interfaces for $\N$, $\Z,\Q$ are the initial semiring, the initial ring and a field of fractions; see Section~\ref{interfaces}.

%Our contributions are:\footnote{The sources are available at:~\url{http://www.eelis.net/research/math-classes/}}%
%\begin{itemize}\itemsep=0pt
% \item The implementation of an algebraic hierarchy based on type classes, addressing the
%issues raised above; see Section~\ref{classes}.
% \item A formalization of many-sorted universal algebra in Coq, including a construction of
%free $\Sigma$-algebras; Section~\ref{univ}.
%\end{itemize}

\section{Algebraic hierarchy using type classes}\label{classes}
\vspace*{-2ex}
\paragraph{Canonical names.}\label{names}
Sharing of notations is an important aspect of the design of a mathematical library. Haskell uses
type classes to overload notations. In Coq we assign a class to every operation, thus avoiding Coq's notation |scope| mechanism.
 Each such operation class has only \emph{one} constructor, hence no record is constructed.
\begin{code}
 Class Equiv A := equiv: relation A.
 Infix "==" := equiv (at level 70, no associativity).
\end{code}
% Instance: Params (@equiv) 2.
\vspace*{-5ex}
\paragraph{Hierarchy.}\label{hierarchy}
In our formalization of algebraic structures we use the structure as (implicit) parameters, but
pack the proofs. This can be nicely organized by using canonical names. For instance, we define:
\begin{code}
Class SemiRing A {e: Equiv A}{plus: RingPlus A}{mult: RingMult A}
                 {zero: RingZero A}{one: RingOne A}:Prop :=
  { semiring_mult_monoid:> Monoid A (op:=mult)(unit:=one)
  ; semiring_plus_monoid:> Monoid A (op:=plus)(unit:=zero)
  ; semiring_plus_comm:> Commutative plus
  ; semiring_mult_comm:> Commutative mult
  ; semiring_distr:> Distribute mult plus
  ; mult_0_l: forall x, 0 * x == 0 }.
\end{code}
where e.g.\ |RingPlus| is the operation class for the semigroup operator.

\emph{Structure-as-parameters} helps setoid-rewriting: type class resolution
can find the equivalence relation in the context.
% A similar style should be possible for, say, the |Ring| tactic, instead of
% declaring the ring structure by a separate command, we would rely on type class resolution to find
% it.
We note that |op| does not depend on the proof that |e| is an equivalence. We use Coq's implicit
quantification (|`{}|) to avoid having to write all the parameters when \emph{stating} a theorem
and Coq's maximally inserted implicit arguments to find the parameters when \emph{applying} a
theorem. Both features are new in Coq and stem from the type class implementation.

We mention the trade-off between bigger contexts versus bigger terms. Our contexts are bigger than
those of telescopes or packed classes. In our experience, this has been relatively harmless: most
terms in the context are there to support canonical names. Bigger terms
\emph{do} cause problems: 1. when proofs are part of mathematical objects we need to share these
proofs to allow rewriting. Moreover, it prohibits Opaque proofs and `proof irrelevance'. 2. The
projection paths may not be canonical.

Coercion pullbacks~\cite{Hints} were introduced to address problems with multiple coercions paths,
as in the definition of a semiring: a type with two monoid structures on it. We avoid some
of these problems by explicitly specifying the fields. We emphasize that the semiring properties are automatically derived from the ring
properties, although the properties of a semiring are not structurally included in the ring
properties.

Manifest fields in records allow us to fix a field of a dependent record.
Luo~\cite{DBLP:conf/types/Luo08} has proposed coersive subtyping to implement manifest fields.
It was conjectured~\cite{Hints} that implementing the algebraic hierarchy with type classes would
be awkward due to problems with equality. We avoided these problems by shifting the fields
from the dependent record to its argument, thus mimicking manifest fields by using type classes.
Since |op| is \emph{instantiated} with |mult|, we need not worry about the
equality |op=mult|.

\section{Universal algebra}\label{univ}
After having implemented concrete algebraic structures, we generalized some of our constructions
by implementing many-sorted universal algebra. A formalization of universal algebra
already exists in Coq~\cite{DBLP:conf/tphol/Capretta99}. We have conveniently redeveloped most of it
using type classes, moreover we have added a categorical framework. For instance, we show that the
term-algebra for a signature is initial. We defined equational theories and their varieties:
the categories of their models. A quote function helps to translate a statement for an instance of
a type class to a statement in the equational logic. We are currently pursuing quoting with
unification~\cite{Hints} using type classes.

We plan to include the first homomorphism theorem and perhaps the soundness theorem for equational
logic

%There is a slight problem when defining the forgetful functor from the category of
%$\Sigma$-algebras to Sets. This problem is caused by our use of the category of all
%categories\footnote{Perhaps we should have used higher categories for this.}.
%We conjecture that this problem disappears when Coq's universe polymorphism is extended to
%definitions.

\section{Interfaces using category theory}\label{interfaces}\label{modul}
The current work was stimulated by our desire~\cite{Riemann} to move between several
implementations in a flexible way. We use ad-hoc polymorphism to capture the natural
numbers without referring to their actual implementation, we have
characterized them as the initial object in the category of semirings and derived many of its
properties from this interface. Unary, binary and machine numbers are
instances of this interface, so we can directly apply these results to them.

We encourage more efficient implementations by assigning the default implementation a
low priority. For example, the distance function on the natural numbers, which is derived from its
semiring structure, is assigned priority 10.
\begin{code}
  Global Program Instance: NatDistance N | 10 := ...
\end{code}
\vspace*{-5ex}
\section{Conclusions}
Telescopes have been criticized~\cite{Packed} for the lack of multiple inheritance and
the efficiency penalty of a long chain of coercion projections. Packed classes~\cite{Packed} provide
a solution to these problems. We provide an alternative solution. We have already
discussed multiple inheritance in Section~\ref{hierarchy}. Moreover, by exposing the
carrier we avoid the chains of projections.

Packed classes use canonical structures for the algebraic hierarchy. Both canonical structures and
type classes may be seen as instances of hints in unification~\cite{Hints}. Some uses of canonical
structures can be replaced by type class instances. The user manual (2.7.15) uses canonical
structures to derive the setoid equality on the natural
numbers in the following example |(S x)==(S y)|. We have conveniently reimplemented this with
type classes with superior proof terms. Canonical structures give 
\begin{code}
@equiv(Build_Setoid nat (@eq nat)(@eq_equivalence nat))(S x)(S y)
\end{code}

which includes an explicit proof that |(@eq nat)| is an equivalence,
whereas we obtain |@equiv nat (@eq nat) (S x) (S y)|.

According to |coqwc|, our development consists of 3103 lines of specifications and 707 lines of
proofs. %targz

% \section{Other systems}
% We will provide a fuller comparison with other systems at a later stage.
% We specifically mention recent work on unification hints in Matita~\cite{Hints}. They however, do
% not address the challenge of proofs in mathematical structures.
\paragraph{Acknowledgements.}
We would like to thank Matthieu Sozeau for discussions and quickly solving numerous small bugs and
feature requests. %Jeremy,Thierry, Claudio, Georges?, Wouter
%\enlargethispage{5mm}
\bibliographystyle{plain}
\bibliography{alg}
\end{document}
